// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';

import { Quat, QuatT } from '../../solarxr-protocol/datatypes/math/quat.js';


/**
 * Data packet containing data for each tracking reset.
 * difference_deg: list of error degrees calculated on a reset (CCW(+),C(-))
 * comp_deg: yaw degrees/s generated through drift compensation (CCW(+),C(-))
 * delta_times: a list of time (seconds) it took for the drift to develop
 * difference_quats: a list of the error quaternions calculated on a reset
 * comp_quats: yaw compensation/s quaternions generated through drift compensation
 */
export class driftCompData implements flatbuffers.IUnpackableObject<driftCompDataT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):driftCompData {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsdriftCompData(bb:flatbuffers.ByteBuffer, obj?:driftCompData):driftCompData {
  return (obj || new driftCompData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsdriftCompData(bb:flatbuffers.ByteBuffer, obj?:driftCompData):driftCompData {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new driftCompData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

driftCompEnable():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

differenceQuats(index: number, obj?:Quat):Quat|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new Quat()).__init(this.bb!.__vector(this.bb_pos + offset) + index * 16, this.bb!) : null;
}

differenceQuatsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

compensationQuats(index: number, obj?:Quat):Quat|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? (obj || new Quat()).__init(this.bb!.__vector(this.bb_pos + offset) + index * 16, this.bb!) : null;
}

compensationQuatsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

differenceDeg(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
}

differenceDegLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

differenceDegArray():Float32Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? new Float32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

compensationDeg(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readFloat32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
}

compensationDegLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

compensationDegArray():Float32Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? new Float32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

resetInterval(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readFloat32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
}

resetIntervalLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

resetIntervalArray():Float32Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? new Float32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

maxResets():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

static startdriftCompData(builder:flatbuffers.Builder) {
  builder.startObject(7);
}

static addDriftCompEnable(builder:flatbuffers.Builder, driftCompEnable:boolean) {
  builder.addFieldInt8(0, +driftCompEnable, +false);
}

static addDifferenceQuats(builder:flatbuffers.Builder, differenceQuatsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, differenceQuatsOffset, 0);
}

static startDifferenceQuatsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(16, numElems, 4);
}

static addCompensationQuats(builder:flatbuffers.Builder, compensationQuatsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, compensationQuatsOffset, 0);
}

static startCompensationQuatsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(16, numElems, 4);
}

static addDifferenceDeg(builder:flatbuffers.Builder, differenceDegOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, differenceDegOffset, 0);
}

static createDifferenceDegVector(builder:flatbuffers.Builder, data:number[]|Float32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createDifferenceDegVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createDifferenceDegVector(builder:flatbuffers.Builder, data:number[]|Float32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]!);
  }
  return builder.endVector();
}

static startDifferenceDegVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addCompensationDeg(builder:flatbuffers.Builder, compensationDegOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, compensationDegOffset, 0);
}

static createCompensationDegVector(builder:flatbuffers.Builder, data:number[]|Float32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createCompensationDegVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createCompensationDegVector(builder:flatbuffers.Builder, data:number[]|Float32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]!);
  }
  return builder.endVector();
}

static startCompensationDegVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addResetInterval(builder:flatbuffers.Builder, resetIntervalOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, resetIntervalOffset, 0);
}

static createResetIntervalVector(builder:flatbuffers.Builder, data:number[]|Float32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createResetIntervalVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createResetIntervalVector(builder:flatbuffers.Builder, data:number[]|Float32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]!);
  }
  return builder.endVector();
}

static startResetIntervalVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addMaxResets(builder:flatbuffers.Builder, maxResets:number) {
  builder.addFieldInt8(6, maxResets, 0);
}

static enddriftCompData(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createdriftCompData(builder:flatbuffers.Builder, driftCompEnable:boolean, differenceQuatsOffset:flatbuffers.Offset, compensationQuatsOffset:flatbuffers.Offset, differenceDegOffset:flatbuffers.Offset, compensationDegOffset:flatbuffers.Offset, resetIntervalOffset:flatbuffers.Offset, maxResets:number):flatbuffers.Offset {
  driftCompData.startdriftCompData(builder);
  driftCompData.addDriftCompEnable(builder, driftCompEnable);
  driftCompData.addDifferenceQuats(builder, differenceQuatsOffset);
  driftCompData.addCompensationQuats(builder, compensationQuatsOffset);
  driftCompData.addDifferenceDeg(builder, differenceDegOffset);
  driftCompData.addCompensationDeg(builder, compensationDegOffset);
  driftCompData.addResetInterval(builder, resetIntervalOffset);
  driftCompData.addMaxResets(builder, maxResets);
  return driftCompData.enddriftCompData(builder);
}

unpack(): driftCompDataT {
  return new driftCompDataT(
    this.driftCompEnable(),
    this.bb!.createObjList<Quat, QuatT>(this.differenceQuats.bind(this), this.differenceQuatsLength()),
    this.bb!.createObjList<Quat, QuatT>(this.compensationQuats.bind(this), this.compensationQuatsLength()),
    this.bb!.createScalarList<number>(this.differenceDeg.bind(this), this.differenceDegLength()),
    this.bb!.createScalarList<number>(this.compensationDeg.bind(this), this.compensationDegLength()),
    this.bb!.createScalarList<number>(this.resetInterval.bind(this), this.resetIntervalLength()),
    this.maxResets()
  );
}


unpackTo(_o: driftCompDataT): void {
  _o.driftCompEnable = this.driftCompEnable();
  _o.differenceQuats = this.bb!.createObjList<Quat, QuatT>(this.differenceQuats.bind(this), this.differenceQuatsLength());
  _o.compensationQuats = this.bb!.createObjList<Quat, QuatT>(this.compensationQuats.bind(this), this.compensationQuatsLength());
  _o.differenceDeg = this.bb!.createScalarList<number>(this.differenceDeg.bind(this), this.differenceDegLength());
  _o.compensationDeg = this.bb!.createScalarList<number>(this.compensationDeg.bind(this), this.compensationDegLength());
  _o.resetInterval = this.bb!.createScalarList<number>(this.resetInterval.bind(this), this.resetIntervalLength());
  _o.maxResets = this.maxResets();
}
}

export class driftCompDataT implements flatbuffers.IGeneratedObject {
constructor(
  public driftCompEnable: boolean = false,
  public differenceQuats: (QuatT)[] = [],
  public compensationQuats: (QuatT)[] = [],
  public differenceDeg: (number)[] = [],
  public compensationDeg: (number)[] = [],
  public resetInterval: (number)[] = [],
  public maxResets: number = 0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const differenceQuats = builder.createStructOffsetList(this.differenceQuats, driftCompData.startDifferenceQuatsVector);
  const compensationQuats = builder.createStructOffsetList(this.compensationQuats, driftCompData.startCompensationQuatsVector);
  const differenceDeg = driftCompData.createDifferenceDegVector(builder, this.differenceDeg);
  const compensationDeg = driftCompData.createCompensationDegVector(builder, this.compensationDeg);
  const resetInterval = driftCompData.createResetIntervalVector(builder, this.resetInterval);

  return driftCompData.createdriftCompData(builder,
    this.driftCompEnable,
    differenceQuats,
    compensationQuats,
    differenceDeg,
    compensationDeg,
    resetInterval,
    this.maxResets
  );
}
}
